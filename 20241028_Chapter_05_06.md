# 20241028 
### Chapter 05. CPU 성능 향상 기법
### Chapter 06. 메모리와 캐시 메모리

---

질문자 : 이강현

답변자 : 양지웅, 최은혜, 오유진

범위 : [혼자 공부하는 컴퓨터 구조 + 운영체제] 5장 ~ 6장

---

### Q1. 클럭, 코어 및 멀티 코어, 스레드 및 멀티 스레드에 대해 아는 만큼 설명해주세요

양지웅 : 클럭은 CPU가 연산이라던가 이런 기능을 실행하는 주기 같은 단위로, 한 클럭 당 일반적으로 하나씩 실행을 합니다. 매 클럭마다 무조건 실행을 하는 것은 아니고 그냥 실행하는 단위가 한 클럭입니다.

오유진 : 코어는 명령어를 실행하는 부분입니다. 한 코어가 하나의 명령어를 수행한다는 보장이 없기 때문에 여러가지의 명령어를 수행하게 된다면 멀티 코어라고 합니다.

최은혜 : 코어는 프로그램을 실행하는 부품을 의미하고, 이 때 스레드는 프로그램을 실행하는 흐름의 단위를 이야기합니다. 멀티 스레드는 한 코어에서 여러 개의 프로그램을 실행할 수 있는 것을 의미합니다.

> 클럭 : 컴퓨터 부품들이 일사불란하게 움직이게 하는 시간 단위. 클럭 속도는 헤르츠(Hz) 단위로 측정하며, 이는 1초에 클럭이 몇 번 반복되는지를 나타냅니다. 클럭 속도는 일정하지 않으며, 클럭 속도를 높인다고 하면 일반적으로 CPU를 빠르게 만들지만, 클럭 속도만으로 CPU의 성능을 올리는 것에는 한계가 있습니다.

> 코어 : 명령어를 실행하는 부품. 코어를 여러 개 포함하고 있는 것을 멀티 코어라고 하며, 이러한 CPU를 멀티코어 CPU 또는 멀티코어 프로세서라고 합니다. CPU의 연산 속도가 꼭 코어 수에 비례하여 증가하지는 않습니다. 예시를 들자면 100인분의 도시락은 한 명의 요리사보다 열 명의 요리사가 만드는 것이 열 배가량 빠르겠지만, 4인분의 도시락은 열 명의 요리사가 만드는 것이 다섯 명의 요리사가 만드는 것보다 특별히 더 빠르지 않은 것으로 예를 들 수 있습니다.

> 스레드 : 실행 흐름의 단위. 하드웨어적 스레드는 ‘하나의 코어가 동시에 처리하는 명령어 단위’ 이고, 소프트웨어적 스레드는 ‘하나의 프로그램에서 독립적으로 실행되는 단위’입니다. 하드웨어적 스레드 측면에서, 하나의 코어로 여러 명령어를 동시에 처리하는 것을 멀티스레드 라고 합니다. 또한, 이러한 CPU를 멀티스레드 프로세서 또는 멀티스레드 CPU라고 합니다. (인텔의 멀티스레드 기술 = 하이퍼스레딩)

### Q2. 명령어 병렬 처리 기법에는 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리가 있습니다. 겹치지 않게 한가지씩 설명해주세요

최은혜 : 명령어 파이프라이닝은 하나의 파이프라인에 모든 명령어를 넣어서 한꺼번에 실행시키는 것을 의미합니다.

오유진 : 비순차적 명령어 처리 기법은 순차적으로 처리하게 될 경우에는 파이프라인이 가동하지 않는 등의 시간상 비효율적인 문제가 생길 수 있습니다. 그래서 명령어의 처리 순서를 조절하여 파이프라인이 쉬지 않고 효율성 있게 처리하는 기법입니다.

양지웅 : 명령어 파이프라이닝은 인출과 같은 일정 부분에 대한 작업이 끝나면 CPU 내부에서 다음 명령어의 인출을 진행하는 작업입니다. 슈퍼스칼라의 경우는 이것 자체를 두개로 늘려 동시에 두개의 인출 작업을 수행하는 기법을 의미합니다.

> 명령어 파이프라이닝 : 공장 생산 라인과 같이 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법. 인출, 해석, 실행, 저장의 각 단계를 겹치지만 않는다면 CPU는 이를 동시에 실행할 수 있습니다. 파이프라이닝이 높은 성능을 가져오기는 하지만, 특정 상황에서는 성능 향상에 실패하는 경우도 있습니다. 이러한 상황을 파이프라인 위험이라고 부릅니다.

> 슈퍼스칼라 : CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 ‘슈퍼스칼라’라고 합니다. 명령어 파이프라인을 하나만 두는 것이 마치 공장 생산 라인을 한 개 두는 것과 같다면 슈퍼스칼라는 공장 생산 라인을 여러 개 두는 것과 같습니다. 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 ‘슈퍼스칼라 프로세서’ 또는 ‘슈퍼스칼라 CPU’라고 합니다.

> 비순차적 명령어 처리 : 명령어들을 순차적으로 실행하지 않는 기법입니다. 프로그램을 위에서 아래로 차례차례 실행하는 방식이던 이전 기법들 중 파이프라인 위험과 같은 예상치 못한 문제들로 인해 명령어는 곧바로 처리되지 못하기도 합니다. 이렇게 명령어 파이프라인이 멈추는 것을 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하며 방지하는 기법을 ‘비순차적 명령어 처리 기법’이라고 합니다.

### Q3. 파이프라인 위험에는 데이터 위험, 제어 위험, 구조적 위험이 있습니다. 겹치지 않게 한가지씩 설명해주세요

양지웅 : 데이터 위험은 멀티 스레드 방식이나 멀티 코어 방식에서 나타날 수 있습니다. 특히 멀티 스레드 방식에서 나타납니다. 같은 데이터를 사용할 경우 동시에 이 데이터에 접근하면 의도치 않은 결과가 나올 수 있기 때문에, 한 스레드에 대한 작업을 할 때 이 데이터에 대한 접근을 막거나 하는 방식으로 동시에 데이터에 접근하는 것을 막으며 데이터 위험을 막을 수 있습니다.

오유진 : 제어 위험은 주로 분기 등으로 인한 ‘프로그램 카운터의 갑작스러운 변화’에 의해 발생합니다. 기본적으로 프로그램 카운터는 ‘현재 실행 중인 명령어의 다음 주소’로 갱신되는데, 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이던 명령어들은 쓸모가 없어집니다. 이는 분기 예측으로 방지하기도 합니다.

최은혜 : 구조적 위험은 명령어들이 동일한 ALU, 레지스터 등과 같은 CPU 를 사용하려고 할 때 발생하는 위험입니다.

> 데이터 위험 : 명령어 간 ‘데이터 의존성’에 의해 발생합니다. 어떤 명령어는 이전 명령어를 끝까지 실행해야만 실행할 수 있는 경우가 있으므로 모든 명령어를 동시에 처리할 수는 없습니다. 예를 들어 명령어 2는 명령어 1의 결과 + 다른 값이라고 했을 때 명령어 1의 실행이 끝나야 명령어 2가 실행이 가능합니다. 이처럼 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것을 ‘데이터 위험’ 이라고 합니다.

> 제어 위험 : 주로 분기 등으로 인한 ‘프로그램 카운터의 갑작스러운 변화’에 의해 발생합니다. 기본적으로 프로그램 카운터는 ‘현재 실행 중인 명령어의 다음 주소’로 갱신되는데, 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이던 명령어들은 쓸모가 없어집니다. 이를 ‘제어 위험’이라고 합니다. 이를 위해 사용하는 기술 중 하나가 ‘분기 예측’입니다. 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술입니다.

> 구조적 위험 : 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생합니다. 구조적 위험은 ‘자원 위험’이라고도 부릅니다.

### Q4. ISA, CISC, RISC에 대해 간단하게 설명해주세요

최은혜 : ISA는 명령어 집합 구조입니다. CISC는 가변 길이 명령어를 활용하기 때문에 프로그램을 이루는 명령어의 수가 적습니다. RISC는 고정 길이 명령어를 활용하기 때문에 프로그램을 이루는 명령어의 수가 많습니다.

오유진 : ISA는 명령어 집합 구조이며, CISC는 가변 길이 명령어를 활용하여 여러 클럭에 걸쳐 명령어를 수행한다는 단점이 있습니다. RISC는 고정 길이 명령어를 활용하여 적은 주소 지정 방식이 있습니다.

양지웅 : ISA는 명령어 집합 구조입니다. CISC는 가변 길이 명령어를 활용하여 많은 명령어를 전부 갖고 있습니다. 장점으로는 메모리를 적게 쓰고 적은 용량의 파일로 실행할 수 있고, 단점으로는 파이프라이닝하기 어렵다는 단점이 있습니다. 이를 보완하기 위한 것이 RISC인데 고정 길이 명령어로 파이프라이닝 하기 쉽다는 장점이 있지만, 다양한 명령어를 활용해야 하기 때문에 프로그램을 이루는 명령어의 수가 많아 파일의 크기가 커진다는 단점이 있습니다.

> ISA : CPU가 이해할 수 있는 명령어들의 모음을 ‘명령어 집합’ 또는 ‘명령어 집합 구조(ISA)’라고 합니다.

> CISC : 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)를 의미합니다. CISC는 ‘가변 길이 명령어’를 활용합니다. 다양한 주소 지정 방식이 있으며, 프로그램을 이루는 명령어의 수가 적습니다. 하지만 여러 클럭에 걸쳐 명령어를 수행한다는 단점이 있어 파이프라이닝하기 어렵다는 단점이 있습니다.

> RISC : 단순하고 적은 명령어 집합을 활용하는 컴퓨터(CPU)를 의미합니다. RISC는 ‘고정 길이 명령어’를 활용하여 적은 주소 지정 방식이 있습니다. 프로그램을 이루는 명령어의 수가 많습니다. 대부분 1 클럭 내외로 명령어를 수행하여 파이프라이닝하기 쉽다는 장점이 있습니다.

### Q5. 휘발성 저장 장치인 RAM의 종류에는 DRAM, SRAM, SDRAM, DDR SDRAM이 있습니다. 이들의 특징에 대해 하나씩 설명해주세요.

양지웅 : DDR SDRAM은 데이터를 주고받는 길의 너비인 대역폭을 넓혀 속도를 빠르게 만든 SDRAM입니다. DDR 뒤의 숫자가 늘어날수록 대역폭이 두배씩 늘어나게 됩니다.

오유진 : DRAM은 SRAM에 비해 가격이 싸고, 속도가 느리고, 집적도가 높습니다. 저장된 데이터가 동적으로 변하기 때문에 일정 주기로 데이터를 다시 저장해야 합니다.

최은혜 : SRAM은 정적 RAM이어서 전원이 공급되고만 있다면 저장된 데이터가 변하지 않습니다. DRAM보다 속도가 빠르고 비싸서 보통 캐시 메모리에 사용됩니다.

> DRAM : 저장된 데이터가 동적으로 변한다(사라진다) 때문에 데이터의 소멸을 막기 위해 일정 주기로 데이터를 다시 저장해야 한다. 우리가 일반적으로 메모리로써 사용하는 RAM은 DRAM이다. 소비 전력이 비교적 낮고, 저렴하고, 집적도가 높기 때문에 대용량으로 설계하기가 용이하다.

> SRAM : 저장된 데이터가 변하지 않는다(전원이 공급되지 않으면 날아가긴 함). DRAM보다 일반적으로 속도도 더 빠르다. DRAM보다 집적도가 낮고, 소비 전력도 크며, 가격도 더 비싸다. 보통 캐시 메모리에서 사용된다.

> SDRAM : 클럭 신호와 동기화된, 발전된 형태의 DRAM이다. ‘클럭 신호와 동기화되었다’라는 말은 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있음을 의미한다.

> DDR SDRAM : 최근 가장 흔히 사용되는 RAM이다. 데이터를 주고받는 길의 너비인 대역폭을 넓혀 속도를 빠르게 만든 SDRAM이다. DDR3 SDRAM, DDR4 SDRAM 처럼 숫자가 늘어나면서 이전보다 대역폭이 두배씩 넓어진다.

### Q6. CPU와 실행 중인 프로그램이 사용하는 ‘논리 주소’를 정보가 실제로 저장된 하드웨어상의 주소를 의미하는 ‘물리 주소’로 어떻게 변환되는지 한계 레지스터와 메모리 관리 장치(MMU)와 같이 설명해주세요

최은혜 : 논리 주소가 한계 레지스터보다 작다면 논리 주소에 베이스 레지스터 값을 더해 논리 주소를 물리 주소로 변환합니다.

오유진 : 논리 주소가 한계 레지스터보다 크다면 인터럽트가 발생하고, 아니라면 베이스 레지스터 값을 더해 물리 주소로 변환합니다.

양지웅 : CPU가 발생시킨 논리 주소가 한계 레지스터보다 작은지 먼저 확인하고, 클 경우 다른 프로그램을 침범할 수 있기 때문에 인터럽트를 발생시킵니다. 이후 베이스 레지스터에 저장된 값을 더하여 논리 주소를 물리 주소로 변환할 수 있습니다. 예를 들어 논리 주소가 100이고, 베이스 레지스터의 값이 1500이라면 물리 주소에서는 1600번지를 찾아가게 됩니다.

> CPU가 발생시킨 논리 주소가 한계 레지스터보다 작은지 확인합니다. 한계 레지스터보다 크다면 인터럽트(트랩)이 발생하고 한계 레지스터보다 작다면 논리 주소에 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환합니다. 예를 들어 현재 베이스 레지스터에 15000이 저장되어 있고, CPU가 발생시킨 논리 주소가 100번지라면 이 논리 주소는 15000 + 100을 하여 물리 주소 15100번지로 변환됩니다.
베이스 레지스터는 프로그램의 가장 작은 물리 주소, 즉 프로그램의 첫 물리 주소를 저장하는 셈이고, 논리 주소는 프로그램의 시작점으로부터 떨어진 거리입니다.

### Q7. 캐시 적중률, 캐시 히트, 캐시 미스에 대해 하나씩 설명해주세요

양지웅 : 캐시 적중률은 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수) 입니다.

오유진 : 캐시 히트는 캐시 메모리 내 데이터가 CPU에서 활용되는 경우입니다.

최은혜 : 캐시 미스는 사용될 것 같아 캐시 메모리에 저장했지만, 예측이 틀려 활용되지 않는 경우입니다.

> 캐시 히트 : 캐시 메모리 내 데이터가 CPU에서 활용될 경우

> 캐시 미스 : 자주 사용될 것으로 예측하여 캐시 메모리에 저장했지만, 예측이 틀려 메모리에서 필요한 데이터를 직접 가져와야 하는 경우

> 캐시 적중률 : 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
